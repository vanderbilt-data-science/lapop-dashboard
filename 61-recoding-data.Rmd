---
title: "61-recoding-data"
output: html_notebook
---

```{r Import libraries, message=FALSE}
library(rlist)
library(data.table)
```

# Recoding Data

In this section we'll rescale data according to the calculations by LAPOP (Issue #32) and add age grouping (Issue #29). Any additional recoding from the raw data should be included here as well. 

Note that weights will be calculated on the fly within the Tableau dashboard as needed.



## Joining data

We'll start by joining to the tables imported from 

LAB_VAL_2018_Core_10plus_countries(v1.0).csv

in 60. 

**NOTE: We need to recode country--country name was done previously in factored data**


NOTE: We are looking up the values instead of directly calculating because some are recoded, other are not. Some have highest mapped to 0, others have lowest. 

```{r join-recodes}

# We'll need to join on both the question name and on the response to get the proper scaled score. 

# Use latest lookup tables

response_labels <- values_labels %>% 
  left_join(questions_cats, by = "column_name") %>% 
  select(column_name, question_es, value, value_recoded, label_es)

# Create countries lookup to Add country name into dataframe
countries <- response_labels %>% 
  filter(column_name == "pais") %>% 
  rename(country = label_es, pais = value) %>% 
  select(pais, country)

## Use recoded values only for answer_measure. If there is no recoding, it's not a measure 
## See Issue 52
## Replace in all cases if answer_dimension 
total_long_common_recoded <- total_long_common %>%
  mutate(answer_measure = as.character(answer_measure)) %>%
  left_join(response_labels, 
            by = c("column_name" = "column_name", "answer_measure" = "value")) %>%
  mutate(answer_measure = if_else(is.na(value_recoded),answer_measure,value_recoded),
         answer_dimension = label_es) %>%
  mutate(pais = as.character(pais)) %>% 
  left_join(countries, by = "pais")  
```



## Add agegroup

Data is now in long format, so we need to recode within a answer_measure IF question_es is q2 Edad


```{r}
# seperating q2 rows and non q2 rows
testing_q2 <- total_long_common_recoded %>% filter(column_name =="q2")
testing_non_q2 <- total_long_common_recoded %>% filter(column_name !="q2")

# answer dimension for q2 rows
testing_q2 <- testing_q2 %>%
  mutate(answer_dimension = as.character(cut(as.numeric(answer_measure),
                                             breaks = c(0, 25, 35, 45, 55, 65, Inf),
                                             labels = c("18-25", "26-35", "36-45", "46-55", "56-65", "66-"))))

# stacking back into full data
total_long_common_recoded <- rbindlist(list(testing_q2, testing_non_q2), use.names=TRUE)
```


